# Algorithm - APS 기본 Stack Part.1

날짜: 2023년 8월 9일

## 스택 - Stack

<aside>
	
    🗒️ 스택의 특성

    - 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
    - 스택에 저장된 자료는 ⭐선형 구조⭐를 가짐
        - 선형 구조 : 자료 간의 관계가 1대1의 관계를 가짐
        - 비선형 구조 : 자료 간의 관계가 1대N의 관계를 가짐
    - 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있음
    - 마지막에 삽입한 자료를 가장 먼저 꺼낸다
        - ⭐후입선출 - Last-In-First-Out ⭐
</aside>

<aside>
	
    🗒️ 스택을 프로그램에서 구현하기 위해 필요한 자료구조와 연산

    - 자료구조 : 자료를 선형으로 저장할 저장소
        - 배열을 사용할 수 있음
        - 저장소 자체를 스택이라 부름
        - 스택에서 마지막 삽입된 원소의 위치를 top라 부름
    - 연산
        - 삽입 : 저장소에 자료를 저장함. 보통 push라고 부름
        - 삭제 : 저장조에서 자료를 꺼냄. 꺼낸 자료는 삽입한 자료의 역순으로 꺼냄. 보통 pop이라고 부름
        - 스택이 공백인지 아닌지를 확인하는 연산 (isEmpty)
        - 스택의 top에 있는 item(원소)을 반환하는 연산 (peek)
</aside>

![Untitled](https://github.com/hluuy/TIL/assets/103430344/778b4b0d-b9ca-4505-acd9-6979235442bb)


- 스택의 push 알고리즘

```python
# append 메소드를 통해 리스트의 마지막에 데이터를 삽입

def push(item) :
		s.append(item)

# 예시
def push(item, size):
    global  top
    top += 1
    if top == size:
        print('overflow!')
    else:
        stack[top] = item

size = 10
stack = [0] * size
top = -1

push(10, size)
top += 1 # push(20)
stack[top] = 20
```

- 스택의 pop 알고리즘

```python
def pop() :
    if len(s) == 0 :
        #underflow
        return
    else :
        return s.pop()

# 예시
def pop():
    global top
    if top == -1:
        print('underflow')
        return  0
    else:
        top -= -1
        return stack[top+1]
    
print(pop())

if top > -1:
    top -= 1
    print(stack[top+1])
```

### ⚠️스택 구현 고려 사항⚠️

- 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 어렵다는 단점이 있음
- 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있음
- 동적 연결리스트를 이용하여 구현하는 방법을 의미함
- 구현이 복잡하다는 단점이 있지만 메모리를 효율적으로 사용한다는 장점을 가짐

### 스택의 응용 : 괄호 검사

<aside>
	
    🗒️ 괄호의 종류 : 대괄호 [ ], 중괄호 { }, 소괄호 ( )

    조건

    1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 함
    2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 함
    3. 괄호 사이에는 포함 관계만 존재
</aside>

![Untitled 1](https://github.com/hluuy/TIL/assets/103430344/d23cc943-e27b-4f0f-ab74-92a64456c6d6)


<aside>
	
    ❗ 괄호를 조사하는 알고리즘 개요

    - 문자열에 있는 괄호를 차례대로 조사하면서 왼쪽 괄호를 만나면 스택에 삽입하고, 오른쪽 괄호를 만나면 스택에서 top괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지 검사
    - 스택이 비어 있으면 조건 1 또는 조건 2에 위배, 짝이 맞지 않으면 조건 3에 위배
    - 마지막 괄호까지 조사한 후에도 스택에 괄호가 남아 있으면 조건 1에 위배
</aside>

### 스택의 응용2 : function call

<aside>
	
    🗒️ Function call

    - 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
        - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조미으로, 후입선출 구조의 스택을 이용하여 수행순서 관리
        - 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입
        - 함수의 실행이 끝나면 시스템 스택(스택 프레임)의 top원소를 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
        - 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 됨
</aside>

![Untitled 2](https://github.com/hluuy/TIL/assets/103430344/d6e8fbfe-4a37-46d2-a369-64831550f417)


---

## 재귀호출

<aside>
	
    ❗ 재귀

    - 자기 자신을 호출하여 순환 수행되는 것
    - 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성
</aside>

<aside>
	
    🗒️ 피보나치 = 0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열

    - 피보나치 수열의 i번 째 값을 계산하는 함수 F를 정의하면 다음과 같음
        - F₀ = 0, F₁ = 1
        - Fi = Fi-1 + Fi-2 for i ≥ 2
    - 위의 정의로부터 피보나치 수열의 i번 째 항을 반환하는 함수를 재귀함수로 구현 가능
</aside>

```python
# 피보나치 수를 구하는 재귀함수
def fibo(n) :
		if n < 2 :
				return n
		else :
				return fibo(n-1) + fibo(n-2)
```

---

## Memoization

⚠️ 앞의 예의 피보나치 수를 구하는 과정은 엄청난 중복 호출이 존재하는 문제점이 있음 ⚠️
